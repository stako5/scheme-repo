// SQL Generation utility for different database dialects

class SQLGenerator {
  constructor(dialect = 'mysql') {
    this.dialect = dialect.toLowerCase();
    this.dataTypeMapping = this.getDataTypeMapping();
  }

  // Generate CREATE TABLE statements for all tables
  generateSchema(tables, relationships = [], options = {}) {
    const {
      includeDropStatements = false,
      includeComments = true,
      includeIndexes = true,
      includeConstraints = true
    } = options;

    let sql = '';

    // Add header comment
    if (includeComments) {
      sql += this.generateHeader();
    }

    // Add DROP statements if requested
    if (includeDropStatements) {
      sql += this.generateDropStatements(tables, relationships);
    }

    // Generate CREATE TABLE statements
    for (const table of tables) {
      sql += this.generateCreateTable(table, includeComments);
    }

    // Generate foreign key constraints
    if (includeConstraints && relationships.length > 0) {
      sql += this.generateForeignKeyConstraints(relationships, includeComments);
    }

    // Generate indexes
    if (includeIndexes) {
      sql += this.generateIndexes(tables, relationships, includeComments);
    }

    return sql;
  }

  // Generate header comment
  generateHeader() {
    const timestamp = new Date().toISOString();
    return `-- Schema generated by Database Schema Designer
-- Generated at: ${timestamp}
-- Database: ${this.dialect.toUpperCase()}

`;
  }

  // Generate DROP statements
  generateDropStatements(tables, relationships) {
    let sql = '';
    
    if (relationships.length > 0) {
      sql += '-- Drop foreign key constraints\n';
      for (const rel of relationships) {
        sql += this.generateDropForeignKey(rel);
      }
      sql += '\n';
    }

    sql += '-- Drop tables\n';
    // Drop in reverse order to handle dependencies
    for (let i = tables.length - 1; i >= 0; i--) {
      sql += this.generateDropTable(tables[i]);
    }
    sql += '\n';

    return sql;
  }

  // Generate CREATE TABLE statement
  generateCreateTable(table, includeComments = true) {
    const { name, description, columns = [] } = table;
    let sql = '';

    if (includeComments && description) {
      sql += `-- ${description}\n`;
    }

    sql += `CREATE TABLE ${this.quoteIdentifier(name)} (\n`;

    // Generate column definitions
    const columnDefs = columns.map(column => this.generateColumnDefinition(column));
    
    // Add primary key constraint if multiple columns
    const primaryKeys = columns.filter(col => col.isPrimaryKey).map(col => col.name);
    if (primaryKeys.length > 1) {
      columnDefs.push(`  CONSTRAINT ${this.quoteIdentifier(`pk_${name}`)} PRIMARY KEY (${primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ')})`);
    }

    sql += columnDefs.join(',\n');
    sql += '\n)';

    // Add table-specific options
    sql += this.getTableOptions();
    sql += ';\n\n';

    return sql;
  }

  // Generate column definition
  generateColumnDefinition(column) {
    const {
      name,
      dataType,
      length,
      precision,
      scale,
      isPrimaryKey,
      isUnique,
      isRequired,
      isAutoIncrement,
      defaultValue,
      description
    } = column;

    let def = `  ${this.quoteIdentifier(name)} `;
    
    // Data type
    def += this.mapDataType(dataType, length, precision, scale);

    // Auto increment
    if (isAutoIncrement && this.supportsAutoIncrement()) {
      def += this.getAutoIncrementSyntax();
    }

    // Primary key (for single column)
    if (isPrimaryKey && this.supportsSingleColumnPrimaryKey()) {
      def += ' PRIMARY KEY';
    }

    // Not null
    if (isRequired) {
      def += ' NOT NULL';
    }

    // Unique
    if (isUnique && !isPrimaryKey) {
      def += ' UNIQUE';
    }

    // Default value
    if (defaultValue !== null && defaultValue !== undefined && defaultValue !== '') {
      def += ` DEFAULT ${this.formatDefaultValue(defaultValue, dataType)}`;
    }

    // Comment
    if (description && this.supportsColumnComments()) {
      def += ` COMMENT ${this.quoteString(description)}`;
    }

    return def;
  }

  // Generate foreign key constraints
  generateForeignKeyConstraints(relationships, includeComments = true) {
    let sql = '';
    
    if (includeComments) {
      sql += '-- Foreign key constraints\n';
    }

    for (const rel of relationships) {
      sql += this.generateForeignKeyConstraint(rel);
    }

    sql += '\n';
    return sql;
  }

  // Generate single foreign key constraint
  generateForeignKeyConstraint(relationship) {
    const {
      name,
      sourceTableName,
      sourceColumnName,
      targetTableName,
      targetColumnName,
      onDelete = 'RESTRICT',
      onUpdate = 'CASCADE'
    } = relationship;

    const constraintName = name || `fk_${sourceTableName}_${targetTableName}`;
    
    return `ALTER TABLE ${this.quoteIdentifier(sourceTableName)} 
  ADD CONSTRAINT ${this.quoteIdentifier(constraintName)} 
  FOREIGN KEY (${this.quoteIdentifier(sourceColumnName)}) 
  REFERENCES ${this.quoteIdentifier(targetTableName)}(${this.quoteIdentifier(targetColumnName)})
  ON DELETE ${onDelete}
  ON UPDATE ${onUpdate};\n`;
  }

  // Generate indexes
  generateIndexes(tables, relationships, includeComments = true) {
    let sql = '';
    
    if (includeComments) {
      sql += '-- Indexes for better performance\n';
    }

    // Foreign key indexes
    for (const rel of relationships) {
      const indexName = `idx_${rel.sourceTableName}_${rel.sourceColumnName}`;
      sql += `CREATE INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteIdentifier(rel.sourceTableName)} (${this.quoteIdentifier(rel.sourceColumnName)});\n`;
    }

    // Unique column indexes
    for (const table of tables) {
      for (const column of table.columns || []) {
        if (column.isUnique && !column.isPrimaryKey) {
          const indexName = `idx_${table.name}_${column.name}_unique`;
          sql += `CREATE UNIQUE INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteIdentifier(table.name)} (${this.quoteIdentifier(column.name)});\n`;
        }
      }
    }

    if (sql !== '-- Indexes for better performance\n') {
      sql += '\n';
    } else {
      sql = '';
    }

    return sql;
  }

  // Generate DROP TABLE statement
  generateDropTable(table) {
    return `DROP TABLE IF EXISTS ${this.quoteIdentifier(table.name)};\n`;
  }

  // Generate DROP FOREIGN KEY statement
  generateDropForeignKey(relationship) {
    const constraintName = relationship.name || `fk_${relationship.sourceTableName}_${relationship.targetTableName}`;
    
    switch (this.dialect) {
      case 'mysql':
        return `ALTER TABLE ${this.quoteIdentifier(relationship.sourceTableName)} DROP FOREIGN KEY ${this.quoteIdentifier(constraintName)};\n`;
      case 'postgresql':
        return `ALTER TABLE ${this.quoteIdentifier(relationship.sourceTableName)} DROP CONSTRAINT ${this.quoteIdentifier(constraintName)};\n`;
      case 'sqlite':
        return `-- SQLite does not support dropping foreign key constraints\n`;
      case 'mssql':
        return `ALTER TABLE ${this.quoteIdentifier(relationship.sourceTableName)} DROP CONSTRAINT ${this.quoteIdentifier(constraintName)};\n`;
      default:
        return `ALTER TABLE ${this.quoteIdentifier(relationship.sourceTableName)} DROP CONSTRAINT ${this.quoteIdentifier(constraintName)};\n`;
    }
  }

  // Map generic data types to dialect-specific types
  mapDataType(dataType, length, precision, scale) {
    const mapping = this.dataTypeMapping[dataType.toUpperCase()];
    
    if (!mapping) {
      return dataType; // Return as-is if no mapping found
    }

    let result = mapping;

    // Handle length parameter
    if (length && result.includes('(n)')) {
      result = result.replace('(n)', `(${length})`);
    }

    // Handle precision and scale
    if (precision && result.includes('(p,s)')) {
      const scaleValue = scale || 0;
      result = result.replace('(p,s)', `(${precision},${scaleValue})`);
    }

    return result;
  }

  // Get data type mapping for current dialect
  getDataTypeMapping() {
    const mappings = {
      mysql: {
        'INTEGER': 'INT',
        'BIGINT': 'BIGINT',
        'SMALLINT': 'SMALLINT',
        'TINYINT': 'TINYINT',
        'VARCHAR': 'VARCHAR(n)',
        'CHAR': 'CHAR(n)',
        'TEXT': 'TEXT',
        'LONGTEXT': 'LONGTEXT',
        'DECIMAL': 'DECIMAL(p,s)',
        'NUMERIC': 'DECIMAL(p,s)',
        'FLOAT': 'FLOAT',
        'DOUBLE': 'DOUBLE',
        'REAL': 'DOUBLE',
        'DATE': 'DATE',
        'TIME': 'TIME',
        'DATETIME': 'DATETIME',
        'TIMESTAMP': 'TIMESTAMP',
        'BOOLEAN': 'BOOLEAN',
        'BIT': 'BIT',
        'JSON': 'JSON',
        'BLOB': 'BLOB',
        'UUID': 'VARCHAR(36)'
      },
      postgresql: {
        'INTEGER': 'INTEGER',
        'BIGINT': 'BIGINT',
        'SMALLINT': 'SMALLINT',
        'TINYINT': 'SMALLINT',
        'VARCHAR': 'VARCHAR(n)',
        'CHAR': 'CHAR(n)',
        'TEXT': 'TEXT',
        'LONGTEXT': 'TEXT',
        'DECIMAL': 'DECIMAL(p,s)',
        'NUMERIC': 'NUMERIC(p,s)',
        'FLOAT': 'REAL',
        'DOUBLE': 'DOUBLE PRECISION',
        'REAL': 'REAL',
        'DATE': 'DATE',
        'TIME': 'TIME',
        'DATETIME': 'TIMESTAMP',
        'TIMESTAMP': 'TIMESTAMP',
        'BOOLEAN': 'BOOLEAN',
        'BIT': 'BIT',
        'JSON': 'JSON',
        'JSONB': 'JSONB',
        'BLOB': 'BYTEA',
        'UUID': 'UUID'
      },
      sqlite: {
        'INTEGER': 'INTEGER',
        'BIGINT': 'INTEGER',
        'SMALLINT': 'INTEGER',
        'TINYINT': 'INTEGER',
        'VARCHAR': 'TEXT',
        'CHAR': 'TEXT',
        'TEXT': 'TEXT',
        'LONGTEXT': 'TEXT',
        'DECIMAL': 'REAL',
        'NUMERIC': 'REAL',
        'FLOAT': 'REAL',
        'DOUBLE': 'REAL',
        'REAL': 'REAL',
        'DATE': 'TEXT',
        'TIME': 'TEXT',
        'DATETIME': 'TEXT',
        'TIMESTAMP': 'TEXT',
        'BOOLEAN': 'INTEGER',
        'BIT': 'INTEGER',
        'JSON': 'TEXT',
        'BLOB': 'BLOB',
        'UUID': 'TEXT'
      },
      mssql: {
        'INTEGER': 'INT',
        'BIGINT': 'BIGINT',
        'SMALLINT': 'SMALLINT',
        'TINYINT': 'TINYINT',
        'VARCHAR': 'VARCHAR(n)',
        'CHAR': 'CHAR(n)',
        'TEXT': 'NVARCHAR(MAX)',
        'LONGTEXT': 'NVARCHAR(MAX)',
        'DECIMAL': 'DECIMAL(p,s)',
        'NUMERIC': 'NUMERIC(p,s)',
        'FLOAT': 'FLOAT',
        'DOUBLE': 'FLOAT',
        'REAL': 'REAL',
        'DATE': 'DATE',
        'TIME': 'TIME',
        'DATETIME': 'DATETIME2',
        'TIMESTAMP': 'DATETIME2',
        'BOOLEAN': 'BIT',
        'BIT': 'BIT',
        'JSON': 'NVARCHAR(MAX)',
        'BLOB': 'VARBINARY(MAX)',
        'UUID': 'UNIQUEIDENTIFIER'
      }
    };

    return mappings[this.dialect] || mappings.mysql;
  }

  // Quote identifier (table/column names)
  quoteIdentifier(identifier) {
    switch (this.dialect) {
      case 'mysql':
        return `\`${identifier}\``;
      case 'postgresql':
        return `"${identifier}"`;
      case 'sqlite':
        return `"${identifier}"`;
      case 'mssql':
        return `[${identifier}]`;
      default:
        return `"${identifier}"`;
    }
  }

  // Quote string values
  quoteString(value) {
    return `'${value.replace(/'/g, "''")}'`;
  }

  // Format default value based on data type
  formatDefaultValue(value, dataType) {
    if (value === null || value === 'NULL') {
      return 'NULL';
    }

    const upperDataType = dataType.toUpperCase();
    
    // String types
    if (upperDataType.includes('VARCHAR') || upperDataType.includes('CHAR') || 
        upperDataType.includes('TEXT') || upperDataType === 'JSON') {
      return this.quoteString(value);
    }

    // Boolean types
    if (upperDataType === 'BOOLEAN' || upperDataType === 'BIT') {
      if (this.dialect === 'sqlite') {
        return value ? '1' : '0';
      }
      return value ? 'TRUE' : 'FALSE';
    }

    // Functions and keywords
    if (value.toUpperCase() === 'CURRENT_TIMESTAMP' || value.toUpperCase() === 'NOW()') {
      switch (this.dialect) {
        case 'mysql':
          return 'CURRENT_TIMESTAMP';
        case 'postgresql':
          return 'CURRENT_TIMESTAMP';
        case 'sqlite':
          return 'CURRENT_TIMESTAMP';
        case 'mssql':
          return 'GETDATE()';
        default:
          return 'CURRENT_TIMESTAMP';
      }
    }

    // Numeric types - return as-is
    return value;
  }

  // Get auto increment syntax
  getAutoIncrementSyntax() {
    switch (this.dialect) {
      case 'mysql':
        return ' AUTO_INCREMENT';
      case 'postgresql':
        return ''; // PostgreSQL uses SERIAL type instead
      case 'sqlite':
        return ' AUTOINCREMENT';
      case 'mssql':
        return ' IDENTITY(1,1)';
      default:
        return ' AUTO_INCREMENT';
    }
  }

  // Get table-specific options
  getTableOptions() {
    switch (this.dialect) {
      case 'mysql':
        return ' ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci';
      case 'postgresql':
        return '';
      case 'sqlite':
        return '';
      case 'mssql':
        return '';
      default:
        return '';
    }
  }

  // Check if dialect supports auto increment
  supportsAutoIncrement() {
    return ['mysql', 'sqlite', 'mssql'].includes(this.dialect);
  }

  // Check if dialect supports single column primary key syntax
  supportsSingleColumnPrimaryKey() {
    return true; // All supported dialects support this
  }

  // Check if dialect supports column comments
  supportsColumnComments() {
    return ['mysql'].includes(this.dialect);
  }
}

module.exports = SQLGenerator;